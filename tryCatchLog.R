# ***************************************************************************
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# ***************************************************************************


# https://cran.r-project.org/web/packages/futile.logger/index.html
library(futile.logger)  # install.packages("futile.logger")

# Solution components:
# - tryCatch/try
# - withCallingHandlers
# - logging
# - limitedLabels
# - sys.calls
# - srcrefs attribute
# - dump.frames
# - options(warn=2) ... for configuring the handling of warning messages (see "?getOption" -> "warn")



#' Convert a call stack into a list of printable strings
#'
#' @description    Converts a call stack into a list of printable strings ("labels") with a limited length per call.
#'                 If source code references are available they are also added in the form
#'                 <file name>#<line number>: executed R expression (call)
#'
#' @param value    a list of calls (function call stack) generated by @seealso \code{\link{sys.calls}})
#' @param compact  if TRUE only calls that contain a source code reference (attribute "srcref") are returned
#'                 (plus always the first call); if FALSE all calls will be returned.
#' @param maxwidth Maximum number of characters per call in the return value (longer strings will be cutted).
#'                 Must be between 40 and 1000
#'
#' @return         A list of strings (one for each call)
#'
#' @details        R does track source code references only if you set the option "keep.source" to TRUE via
#'                 \code{options(keep.source = TRUE)}. Without this option this function cannot enrich source code references.
#'                 If you use @seealso \code{\link{Rscript}} to start a non-interactive R script as batch job you
#'                 have to set this option since it is FALSE by default. You can add this option to your
#'                 @seealso \link{.Rprofile} file or use a startup R script that sets this option and sources your
#'                 actual R script then.
#'
#'                 This function is base on the undocumented @seealso \code{\link{limitedLabels}} function of the base package.
#'                 The source code can be viewed by entering \code{limitedLabels} in the R console.
#'                 The attributes required to add source file names and line numbers to the calls (srcref and srcfile)
#'                 and how they are created internally are explained in this article:
#                  \url{https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Murdoch.pdf}
#'
#' @examples       \dontrun{limitedLabelsCompact( sys.calls(), TRUE)}
limitedLabelsCompact <- function(value, compact = FALSE, maxwidth = getOption("width") - 5L)
{
  # create vector of source references (file and row numbers) for each call item of the stack
  srcrefs <- sapply(value, function(v)
                           {
                             srcref <- attr(v,"srcref")
                             if (!is.null(srcref))
                             {
                               srcfile <- attr(srcref, "srcfile")
                               paste0(basename(srcfile$filename), "#", srcref[1L], ": ")
                             }
                             else ""
                           })

  # create a list of only first line of code for each call stack item
  if (compact == TRUE)
    value <- lapply(as.character(value), function(x) strsplit(x, "\n")[[1]][1])


  # combine source references with the call stack and ident multi-line code
  value <- gsub("\n", "\n    ", as.character(value))
  value <- paste0(srcrefs, value)

  # cut lines that are too long
  if (is.null(maxwidth) || maxwidth < 40L)
    maxwidth <- 40L
  maxwidth <- min(maxwidth, 1000L)
  strtrim(value, maxwidth)

  if (compact == TRUE)
  {
    # return only call stack items that contain a source reference
    srcrefs.available <- srcrefs != ""
    srcrefs.available[1] <- TRUE          # always return the first row!
    value <- value[srcrefs.available]
  }

  return(value)
}



#' Pretty formatted call stack enriched with the source file names and row numbers
#'
#' @description Enriches the current call stack with the source file names and row numbers
#'              to track the location of thrown conditions and generates a prettily formatted list
#'              of strings
#'
#' @param call.stack       Call stack object created by @seealso \code{\link{sys.calls()"}}
#' @param omit.last.items  Number of call stack items to drop from the end of the full stack trace
#' @param compact          TRUE will return only call stack items with source code references (FALSE all)
#'
#' @return  The call stack (sys.calls) without the last number of function calls (given by "omit.last.items")
#'          to remove irrelevant calls caused e. g. by exception handler (@seealso \code{\link{withCallingHandlers}})
#'          or restarts (of warnings).
#'
#' @Details How to read the call stack:
#'          1. Call stack items consist of:
#'             <call stack item number> [<file name>#<row number>:] expression executed by this code line
#'          2. The last call stack items with a file name and row number points to the source code line causing the error.
#'          3. Ignore all call stack items that do not start with a file name and row number (R internal calls only)
#'
#'         You should only call this function from within @seealso \code{\link{withCallingHandlers}}, NOT from within @seealso \code{\link{tryCatch}}
#'         since tryCatch  unwinds the call stack to the tryCatch position and the source of the condition cannot be identified anymore.
get.pretty.call.stack <- function(call.stack, omit.last.items = 0, compact = FALSE)
{
  if (is.null(call.stack))
    return("")

  # remove the last calls that shall be omitted
  if (length(call.stack) > omit.last.items)
    call.stack <- call.stack[1:(length(call.stack)
                                - omit.last.items)]

  pretty.call.stack <- limitedLabelsCompact(call.stack, compact)
  call.stack.formatted <- paste(" ", 1:length(pretty.call.stack), pretty.call.stack, collapse = "\n")

  return(call.stack.formatted)
}



buildLogMessage <- function(log.message, call.stack, omit.last.items = 0) {
  paste(log.message,
        "Compact call stack:",
        get.pretty.call.stack(call.stack, omit.last.items, compact = TRUE),
        "Full call stack:",
        get.pretty.call.stack(call.stack, omit.last.items),   # ignore 2 stacked functions here
        sep = "\n")
}



#' Expression execution with error handling and logging of conditions
#'
#' @description This function evaluates an expression passed in the \code{expr} parameter and executes
#'              the error handler function passed as parameter \code{error} in case of an error condition.
#'              The \code{finally} expression is then always evaluated at the end.
#'              Conditions are logged including the call stack.
#'
#' @param expr                 expression to be evaluated
#' @param error                error handler function
#' @param finally              expression to be evaluated at the end
#' @param dump.errors.to.file  if TRUE: Saves a dump of the workspace and the call stack named "dump_<YYYYMMDD_HHMMSS>.rda"
#'
#' @return                     the value of the expression passed in as parameter "expr"
#' @export
#'
#' @details Before you can call \code{tryCatchLog} you have to initialize the \code{futile.logger} package first:
#'          \code{library(futile.logger)
#'          flog.appender(appender.file("my_app.log"))
#'          flog.threshold(INFO)    # TRACE, DEBUG, INFO, WARN, ERROR, FATAL}
#'
#'          The following conditions are logged using the @seealso \code{\link[futile.logger]{}} package:
#'          \enumerate{
#'          \item error   -> \code{\link[futile.logger]{flog.error}}
#'          \item warning -> \code{\link[futile.logger]{flog.warn}}
#'          \item message -> \code{\link[futile.logger]{flog.info}}
#'          }
#'
#'          The log contains the call stack with the file names and line numbers (if available).
#'
#'          R does track source code references only if you set the option \code{keep.source} to TRUE via
#'          \code{options(keep.source = TRUE)}. Without this option this function cannot enrich source code references.
#'          If you use @seealso \code{\link{Rscript}} to start a non-interactive R script as batch job you
#'          have to set this option since it is FALSE by default. You can add this option to your
#'          \link{.Rprofile} file or use a startup R script that sets this option and sources your
#'          actual R script then.
#'
#'          By default, most packages are built without source reference information.
#'          Setting the environment variable \code{R_KEEP_PKG_SOURCE=yes} before installing a source package
#'          will tell R to keep the source references. You can also use \code{options(keep.source.pkgs = TRUE)}
#'          before you install a package.
#'
#'          Setting the parameter \code{dump.errors.to.file} to TRUE allows a post mortem analysis of the program state
#'          that led to the error. The dump contains the workspace and in the variable "last.dump"
#'          the call stack (\code{\link{sys.frames}}). This feature is very helpful for non-interactive R scripts ("batches").
#'          To start a post mortem analysis after an error open a new R session and enter:
#'             \code{load("dump_20161016_164050.rda")   # replace the dump file name with your real file name
#'             debugger(last.dump)}
#'
#'          @section Best practices
#'
#'          To avoid that too many dump files fill your disk space you should omit the \code{dump.errors.to.file}
#'          parameter and set its value using the option \code{tryCatchLog.dump.errors.to.file} in your
#'          \link{.Rprofile} file instead (or in a startup R script that sources your actual script).
#'          In case of an error (that you can reproduce) you set the option to \code{TRUE} and rerun your script.
#'          Then you can examine the program state that led to the error.
#' @example \code{\dontrun{tryCatchLog(log(-1))   # logs a warning}}
tryCatchLog <- function(expr,
                        error = getOption("error", default = stop),
                        finally = NULL,
                        dump.errors.to.file = getOption("tryCatchLog.dump.errors.to.file", FALSE))
{
  tryCatch(
    withCallingHandlers(expr,
                        error = function(e)
                        {
                          call.stack <- sys.calls()                                 # "sys.calls" within "withCallingHandlers" is like a traceback!
                          log.message <- e$message

                          # Save dump to allow post mortem debugging?
                          # See"?dump.frames" on how to load and debug the dump in a later interactive R session!
                          # See https://stackoverflow.com/questions/40421552/r-how-make-dump-frames-include-all-variables-for-later-post-mortem-debugging/40431711#40431711
                          # why you should avoid dump.frames(to.file = TRUE)...
                          if (dump.errors.to.file == TRUE)
                          {
                            dump.file.name <- format(Sys.time(), format = "dump_%Y%m%d_%H%M%S")   # use %OS3 (= seconds incl. milliseconds) for finer precision
                            dump.frames()
                            save.image(file = paste0(dump.file.name, ".rda"))
                            log.message <- paste0(log.message, "\nEnvironment dumped into file: ", dump.file.name, ".rda")
                          }
# x <<- sys.calls() # just for internal debugging purposes
                          flog.error(buildLogMessage(log.message, call.stack, 1))   # ignore  function calls to this this handler

                        },
                        warning = function(w)
                        {

                          call.stack <- sys.calls()                                 # "sys.calls" within "withCallingHandlers" is like a traceback!
                          flog.warn(buildLogMessage(w$message, call.stack, 1))      # ignore last function calls to this handler
                        }
                        , message = function(m)                                     # Remember: You can ignore messages by setting the log level above "info"
                        {

                          call.stack <- sys.calls()                                 # "sys.calls" within "withCallingHandlers" is like a traceback!
                          flog.info(buildLogMessage(m$message, call.stack, 1))      # ignore last function calls to this handler
                        }
    ),       # end of withCallingHandlers
    error = error,                # pass error handler argument of tryCatchLog to tryCatch
    finally = finally)
}





