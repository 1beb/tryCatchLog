% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tryCatchLog.R
\name{tryCatchLog}
\alias{tryCatchLog}
\title{Try an expression with condition logging and error handling}
\usage{
tryCatchLog(expr, error = getOption("error", default = stop),
  finally = NULL,
  dump.errors.to.file = getOption("tryCatchLog.dump.errors.to.file", FALSE),
  silent.warnings = getOption("tryCatchLog.silent.warnings", FALSE),
  silent.messages = getOption("tryCatchLog.silent.messages", FALSE))
}
\arguments{
\item{expr}{expression to be evaluated}

\item{error}{error handler function}

\item{finally}{expression to be evaluated at the end}

\item{dump.errors.to.file}{TRUE: Saves a dump of the workspace and the call stack named \code{dump_<YYYYMMDD_HHMMSS>.rda}}

\item{silent.warnings}{TRUE: Warnings are logged, but not propagated to the caller.\cr
FALSE: Warnings are logged and treated according to the global
setting in \code{\link{getOption}("warn")}. See also \code{\link{warning}}.}

\item{silent.messages}{TRUE: Messages are logged, but not propagated to the caller.\cr
FALSE: Messages are logged and propagated to the caller.}
}
\value{
the value of the expression passed in as parameter "expr"
}
\description{
This function evaluates an expression passed in the \code{expr} parameter and executes
the error handler function passed as parameter \code{error} in case of an error condition.
The \code{finally} expression is then always evaluated at the end.
Conditions are logged with the function call stack (including file names and line numbers).
}
\details{
This function shall overcome some drawbacks of the standard \code{\link{tryCatch}} function.\cr
         For more details see \url{https://github.com/aryoda/tryCatchLog}.

         Before you call \code{tryCatchLog} for the first time you should initialize the \pkg{futile.logger} first:

         \preformatted{  library(futile.logger)
  flog.appender(appender.file("my_app.log"))
  flog.threshold(INFO)    # TRACE, DEBUG, INFO, WARN, ERROR, FATAL}

         If you don't initialize the \pkg{futile.logger} at all the logging information will be written on the console only.

         The following conditions are logged using the \pkg{futile.logger} package:
         \enumerate{
         \item error   -> \code{\link[futile.logger]{flog.error}}
         \item warning -> \code{\link[futile.logger]{flog.warn}}
         \item message -> \code{\link[futile.logger]{flog.info}}
         }

         The log contains the call stack with the file names and line numbers (if available).

         R does track source code references only if you set the option \code{keep.source} to TRUE via
         \code{options(keep.source = TRUE)}. Without this option this function cannot enrich source code references.
         If you use \command{Rscript} to start a non-interactive R script as batch job you
         have to set this option since it is FALSE by default. You can add this option to your
         \link{.Rprofile} file or use a startup R script that sets this option and sources your
         actual R script then.

         By default, most packages are built without source reference information.
         Setting the environment variable \code{R_KEEP_PKG_SOURCE=yes} before installing a source package
         will tell R to keep the source references. You can also use \code{options(keep.source.pkgs = TRUE)}
         before you install a package.

         Setting the parameter \code{dump.errors.to.file} to TRUE allows a post-mortem analysis of the program state
         that led to the error. The dump contains the workspace and in the variable "last.dump"
         the call stack (\code{\link{sys.frames}}). This feature is very helpful for non-interactive R scripts ("batches").

         To start a post-mortem analysis after an error open a new R session and enter:
            \code{load("dump_20161016_164050.rda")   # replace the dump file name with your real file name
            debugger(last.dump)}

         Note that the dump does \bold{not} contain the loaded packages when the dump file was created
         and a dump loaded into memory does therefore \bold{not} use exactly the same search path.
         This means:

         \enumerate{
         \item{the program state is not exactly reproducible if objects are stored within a package namespace}
         \item{you cannot step through your source code in a reproducible way after loading the image
               if your source code calls functions of non-default packages}
         }
}
\section{Best practices}{


         To \bold{avoid that too many dump files filling your disk space} you should omit the \code{dump.errors.to.file}
         parameter and instead set its default value using the option \code{tryCatchLog.dump.errors.to.file} in your
         \link{.Rprofile} file instead (or in a startup R script that sources your actual script).
         In case of an error (that you can reproduce) you set the option to \code{TRUE} and re-run your script.
         Then you are able to examine the program state that led to the error by debugging the saved dump file.

         To see the \bold{source code references (source file names and line numbers)} in the stack traces you must
         set this option before executing your code:\cr
         \code{options(keep.source = TRUE)}

         You can \bold{execute your code as batch with \code{\link{Rscript}} using this shell script command}:\cr
         \code{Rscript -e "options(keep.source = TRUE); source('my_main_function.R')"}
}
\examples{
tryCatchLog(log(-1))   # logs a warning
}
\seealso{
\code{\link{tryLog}}, \code{\link{limitedLabels}}, \code{\link{get.pretty.call.stack}}, \code{\link{getOption}}
}

