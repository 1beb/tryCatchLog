# ***************************************************************************
# Copyright (C) 2016 Juergen Altfeld (R@altfeld-im.de)
# ---------------------------------------------------------------------------
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# ***************************************************************************



# # Do not use this since it makes all function of these packages available
# # (even those who are not used by this package!)
# #' @import utils
# #' @import futile.logger
# NULL

# Better import only the required functions to reduce the dependencies and make them explicit:
# Note: This is an optional step if you qualify all your external function calls with the package name and "::"
#       together with declaring the required packaged in the "Imports" section of the DESCRIPTION file.
#       Source: https://cran.r-project.org/doc/manuals/R-exts.html#Specifying-imports-and-exports
#' @importFrom futile.logger flog.error flog.warn flog.info
#' @importFrom utils         dump.frames
NULL

# https://cran.r-project.org/web/packages/futile.logger/index.html
# library(futile.logger)  # install.packages("futile.logger")



#' Convert a call stack into a list of printable strings
#'
#' @description    Converts a call stack into a list of printable strings ("labels") with a limited length per call.
#'                 If source code references are available they are also added in the form
#'                 \<file name\>#\<line number\>: executed R expression (call)
#'
#' @param value    a list of calls ("call.stack") generated by \code{\link{sys.calls}}
#' @param compact  if TRUE only calls that contain a source code reference (attribute "srcref") are returned
#'                 (plus always the first call); if FALSE all calls will be returned.
#' @param maxwidth Maximum number of characters per call in the return value (longer strings will be cutted).
#'                 Must be between 40 and 1000
#'
#' @return         A list of strings (one for each call)
#'
#' @details        R does track source code references only if you set the option "keep.source" to TRUE via
#'                 \code{options(keep.source = TRUE)}. Without this option this function cannot enrich source code references.
#'                 If you use \command{Rscript} to start a non-interactive R script as batch job you
#'                 have to set this option since it is FALSE by default. You can add this option to your
#'                 \link{.Rprofile} file or use a startup R script that sets this option and sources your
#'                 actual R script then.
#'
#'                 This function is base on the undocumented \code{\link{limitedLabels}} function of the base package.
#'                 The source code can be viewed by entering \code{limitedLabels} in the R console.
#'                 The attributes required to add source file names and line numbers to the calls (srcref and srcfile)
#'                 and how they are created internally are explained in this article:
#'                 \url{https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Murdoch.pdf}
#'
#' @seealso        \code{\link{sys.calls}}, \code{\link{tryCatchLog}}, \code{\link{get.pretty.call.stack}}
#' @examples
#' limitedLabelsCompact(sys.calls(), TRUE)
#' @export
limitedLabelsCompact <- function(value, compact = FALSE, maxwidth = getOption("width") - 5L)
{
  # create vector of source references (file and row numbers) for each call item of the stack
  srcrefs <- sapply(value, function(v)
                           {
                             srcref <- attr(v,"srcref")
                             if (!is.null(srcref))
                             {
                               srcfile <- attr(srcref, "srcfile")
                               paste0(basename(srcfile$filename), "#", srcref[1L], ": ")
                             }
                             else ""
                           })

  # create a list of only first line of code for each call stack item
  if (compact == TRUE)
    value <- lapply(as.character(value), function(x) strsplit(x, "\n")[[1]][1])


  # combine source references with the call stack and ident multi-line code
  value <- gsub("\n", "\n    ", as.character(value))
  value <- paste0(srcrefs, value)

  # cut lines that are too long
  if (is.null(maxwidth) || maxwidth < 40L)
    maxwidth <- 40L
  maxwidth <- min(maxwidth, 1000L)
  strtrim(value, maxwidth)

  if (compact == TRUE)
  {
    # return only call stack items that contain a source reference
    srcrefs.available <- srcrefs != ""
    srcrefs.available[1] <- TRUE          # always return the first row!
    value <- value[srcrefs.available]
  }

  return(value)
}



#' Pretty formatted call stack enriched with the source file names and row numbers
#'
#' @description Enriches the current call stack with the source file names and row numbers
#'              to track the location of thrown conditions and generates a prettily formatted list
#'              of strings
#'
#' @param call.stack       Call stack object created by \code{\link{sys.calls}}
#' @param omit.last.items  Number of call stack items to drop from the end of the full stack trace
#' @param compact          TRUE will return only call stack items that have a source code reference (FALSE all)
#'
#' @return  The call stack (\code{\link{sys.calls}}) without the last number of function calls (given by "omit.last.items")
#'          to remove irrelevant calls caused e. g. by exception handler (\code{\link{withCallingHandlers}})
#'          or restarts (of warnings).
#'
#' @details How to read the call stack:
#'          \enumerate{
#'          \item Call stack items consist of:\cr
#'             \code{<call stack item number> [<file name>#<row number>:] <expression executed by this code line>}
#'          \item The last call stack items with a file name and row number points to the source code line causing the error.
#'          \item Ignore all call stack items that do not start with a file name and row number (R internal calls only)
#'          }
#'          You should only call this function from within \code{\link{withCallingHandlers}}, NOT from within \code{\link{tryCatch}}
#'          since tryCatch unwinds the call stack to the tryCatch position and the source of the condition cannot be identified anymore.
#' @seealso \code{\link{tryCatchLog}}, \code{\link{tryLog}}, \code{\link{limitedLabelsCompact}}
#' @export
get.pretty.call.stack <- function(call.stack, omit.last.items = 0, compact = FALSE)
{
  if (is.null(call.stack))
    return("")

  # remove the last calls that shall be omitted
  if (length(call.stack) > omit.last.items)
    call.stack <- call.stack[1:(length(call.stack)
                                - omit.last.items)]

  pretty.call.stack <- limitedLabelsCompact(call.stack, compact)
  call.stack.formatted <- paste(" ", 1:length(pretty.call.stack), pretty.call.stack, collapse = "\n")

  return(call.stack.formatted)
}



#' Internal helper function to build a log message
#'
#' @description  Combines a log message with a compact and a detailled stack trace with the option
#'               to ignore the last x stack trace items (normally created due to internal error handling
#'               and therefore irrelevant for the user).
#'
#' @param log.message      a text message
#' @param call.stack       a call stack created by \code{\link{sys.calls}}
#' @param omit.last.items  number of stack trace items to ignore (= last x items)
#'
#' @return       A ready to use log message with a pretty printed compact and detailled stack trace
#' @note         THIS IS A PACKAGE INTERNAL FUNCTION AND THEREFOR NOT EXPORTED.
buildLogMessage <- function(log.message, call.stack, omit.last.items = 0) {
  paste(log.message,
        "Compact call stack:",
        get.pretty.call.stack(call.stack, omit.last.items, compact = TRUE),
        "Full call stack:",
        get.pretty.call.stack(call.stack, omit.last.items),   # ignore 2 stacked functions here
        sep = "\n")
}



#' Try an expression with condition logging and error handling
#'
#' This function evaluates an expression passed in the \code{expr} parameter and executes
#' the error handler function passed as parameter \code{error} in case of an error condition.
#' The \code{finally} expression is then always evaluated at the end.
#' Conditions are logged with the function call stack (including file names and line numbers).
#'
#' @param expr                 expression to be evaluated
#' @param error                error handler function
#' @param finally              expression to be evaluated at the end
#' @param dump.errors.to.file  TRUE: Saves a dump of the workspace and the call stack named \code{dump_<YYYYMMDD_HHMMSS>.rda}
#' @param silent.warnings      TRUE: Warnings are logged, but not propagated to the caller.\cr
#'                             FALSE: Warnings are logged and treated according to the global
#'                             setting in \code{\link{getOption}("warn")}. See also \code{\link{warning}}.
#' @param silent.messages      TRUE: Messages are logged, but not propagated to the caller.\cr
#'                             FALSE: Messages are logged and propagated to the caller.
#'
#' @return                     the value of the expression passed in as parameter "expr"
#'
#' @details This function shall overcome some drawbacks of the standard \code{\link{tryCatch}} function.\cr
#'          For more details see \url{https://github.com/aryoda/tryCatchLog}.
#'
#'          Before you call \code{tryCatchLog} for the first time you should initialize the \pkg{futile.logger} first:
#'
#'          \preformatted{  library(futile.logger)
#'   flog.appender(appender.file("my_app.log"))
#'   flog.threshold(INFO)    # TRACE, DEBUG, INFO, WARN, ERROR, FATAL}
#'
#'          If you don't initialize the \pkg{futile.logger} at all the logging information will be written on the console only.
#'
#'          The following conditions are logged using the \pkg{futile.logger} package:
#'          \enumerate{
#'          \item error   -> \code{\link[futile.logger]{flog.error}}
#'          \item warning -> \code{\link[futile.logger]{flog.warn}}
#'          \item message -> \code{\link[futile.logger]{flog.info}}
#'          }
#'
#'          The log contains the call stack with the file names and line numbers (if available).
#'
#'          R does track source code references only if you set the option \code{keep.source} to TRUE via
#'          \code{options(keep.source = TRUE)}. Without this option this function cannot enrich source code references.
#'          If you use \command{Rscript} to start a non-interactive R script as batch job you
#'          have to set this option since it is FALSE by default. You can add this option to your
#'          \link{.Rprofile} file or use a startup R script that sets this option and sources your
#'          actual R script then.
#'
#'          By default, most packages are built without source reference information.
#'          Setting the environment variable \code{R_KEEP_PKG_SOURCE=yes} before installing a source package
#'          will tell R to keep the source references. You can also use \code{options(keep.source.pkgs = TRUE)}
#'          before you install a package.
#'
#'          Setting the parameter \code{dump.errors.to.file} to TRUE allows a post-mortem analysis of the program state
#'          that led to the error. The dump contains the workspace and in the variable "last.dump"
#'          the call stack (\code{\link{sys.frames}}). This feature is very helpful for non-interactive R scripts ("batches").
#'
#'          To start a post-mortem analysis after an error open a new R session and enter:
#'             \code{load("dump_20161016_164050.rda")   # replace the dump file name with your real file name
#'             debugger(last.dump)}
#'
#'          Note that the dump does \bold{not} contain the loaded packages when the dump file was created
#'          and a dump loaded into memory does therefore \bold{not} use exactly the same search path.
#'          This means:
#'
#'          \enumerate{
#'          \item{the program state is not exactly reproducible if objects are stored within a package namespace}
#'          \item{you cannot step through your source code in a reproducible way after loading the image
#'                if your source code calls functions of non-default packages}
#'          }
#'
#' @section Best practices:
#'
#'          To \bold{avoid that too many dump files filling your disk space} you should omit the \code{dump.errors.to.file}
#'          parameter and instead set its default value using the option \code{tryCatchLog.dump.errors.to.file} in your
#'          \link{.Rprofile} file instead (or in a startup R script that sources your actual script).
#'          In case of an error (that you can reproduce) you set the option to \code{TRUE} and re-run your script.
#'          Then you are able to examine the program state that led to the error by debugging the saved dump file.
#'
#'          To see the \bold{source code references (source file names and line numbers)} in the stack traces you must
#'          set this option before executing your code:\cr
#'          \code{options(keep.source = TRUE)}
#'
#'          You can \bold{execute your code as batch with \code{\link{Rscript}} using this shell script command}:\cr
#'          \code{Rscript -e "options(keep.source = TRUE); source('my_main_function.R')"}
#'
#' @seealso \code{\link{tryLog}}, \code{\link{limitedLabels}}, \code{\link{get.pretty.call.stack}}, \code{\link{getOption}}
#' @examples
#' tryCatchLog(log(-1))   # logs a warning
#' @export
tryCatchLog <- function(expr,
                        error = getOption("error", default = stop),
                        finally = NULL,
                        dump.errors.to.file = getOption("tryCatchLog.dump.errors.to.file", FALSE),
                        silent.warnings = getOption("tryCatchLog.silent.warnings", FALSE),
                        silent.messages = getOption("tryCatchLog.silent.messages", FALSE))
{
  tryCatch(
    withCallingHandlers(expr,
                        error = function(e)
                        {
                          call.stack <- sys.calls()              # "sys.calls" within "withCallingHandlers" is like a traceback!
                          log.message <- e$message               # TODO: Should we use conditionMessage instead?

                          # Save dump to allow post mortem debugging?
                          # See"?dump.frames" on how to load and debug the dump in a later interactive R session!
                          # See https://stackoverflow.com/questions/40421552/r-how-make-dump-frames-include-all-variables-for-later-post-mortem-debugging/40431711#40431711
                          # why you should avoid dump.frames(to.file = TRUE)...
                          if (dump.errors.to.file == TRUE)
                          {
                            dump.file.name <- format(Sys.time(), format = "dump_%Y%m%d_%H%M%S")   # use %OS3 (= seconds incl. milliseconds) for finer precision
                            utils::dump.frames()
                            save.image(file = paste0(dump.file.name, ".rda"))
                            # https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17116
                            # wait for the enhanced version to be released in spring 2017
                            # dump.frames(dumpto = dump.file.name, to.file = TRUE, include.GlobalEnv = TRUE)  # test it now by using "dump.frames.dev()"
                            log.message <- paste0(log.message, "\nCall stack environments dumped into file: ", dump.file.name, ".rda")
                          }
# x <<- sys.calls() # just for internal debugging purposes
                          futile.logger::flog.error(buildLogMessage(log.message, call.stack, 1))   # ignore  function calls to this this handler

                        },
                        warning = function(w)
                        {

                          call.stack <- sys.calls()                                 # "sys.calls" within "withCallingHandlers" is like a traceback!
                          futile.logger::flog.warn(buildLogMessage(w$message, call.stack, 1))      # ignore last function calls to this handler

                          # Suppresses the warning (logs it only)?
                          if (silent.warnings) {
                            invokeRestart("muffleWarning")           # the warning will NOT bubble up now!
                          } else {
                            # The warning bubbles up and the execution resumes only if no warning handler is established
                            # higher in the call stack via try or tryCatch
                          }
                        }
                        , message = function(m)                                     # Remember: You can ignore messages by setting the log level above "info"
                        {

                          call.stack <- sys.calls()                                 # "sys.calls" within "withCallingHandlers" is like a traceback!
                          futile.logger::flog.info(buildLogMessage(m$message, call.stack, 1))      # ignore last function calls to this handler

                          if (silent.messages) {
                            invokeRestart("muffleMessage")            # the message will not bubble up now (logs it only)
                          } else {
                            # Just to make it clear here: The message bubbles up now
                          }
                        }
    ),       # end of withCallingHandlers
    error = error,                # pass error handler argument of tryCatchLog to tryCatch
    finally = finally)
}





#' Try an expression with condition logging and error recovery
#'
#' \code{tryLog} is a wrapper function around \code{\link{tryCatchLog}}
#' that traps any errors that occur during the evaluation of an expression without stopping the execution
#' of the script (similar to \code{\link{try}}). Errors, warnings and messages are logged.
#' In contrast to \code{\link{tryCatchLog}} it returns but does not stop in case of an error and therefor does
#' not have the \code{error} and \code{finally} parameters to pass in custom handler functions.
#'
#' @inheritParams tryCatchLog
#'
#' @details \code{tryLog} is implemented using \code{\link{tryCatchLog}}. If you need need more flexibility for
#'          catching and handling errors use the latter.
#'          Error messages are never printed to the \code{\link{stderr}} connection but logged only.
#'
#' @return The value of the expression (if \code{expr} is evaluated without an error.\cr
#'         In case of an error: An invisible object of the class \code{"try-error"} containing the error message
#'         and error condition as the \code{"condition"} attribute.
#'
#' @seealso \code{\link{tryCatchLog}}
#' @examples
#' tryLog(log(-1))   # logs a warning
#' tryLog(log("a"))  # logs an error
#' @export
tryLog <- function(expr,
                   dump.errors.to.file = getOption("tryCatchLog.dump.errors.to.file", FALSE),
                   silent.warnings = getOption("tryCatchLog.silent.warnings", FALSE),
                   silent.messages = getOption("tryCatchLog.silent.messages", FALSE))
{
  tryCatchLog(expr = expr,
              dump.errors.to.file = dump.errors.to.file,
              error = function(e) {
                msg <- conditionMessage(e)
                invisible(structure(msg, class = "try-error", condition = e))
              },
              silent.warnings = silent.warnings,
              silent.messages = silent.messages)
}
